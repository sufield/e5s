diff --git a/docs/INVARIANTS.md b/docs/INVARIANTS.md
index 82c2612..d67cd23 100644
--- a/docs/INVARIANTS.md
+++ b/docs/INVARIANTS.md
@@ -91,12 +91,15 @@ func NewIdentityCredentialFromComponents(trustDomain *TrustDomain, path string)
 - **Rationale**: IdentityCredential without trust domain is meaningless
 
 ```go
-// Invariant: path defaults to "/" if empty, never stored as empty string
-// Location: NewIdentityCredentialFromComponents (line 26-28)
+// Invariant: path is normalized and validated on construction
+// Location: NewIdentityCredentialFromComponents, normalizePath (line 26-28, 117-157)
 func NewIdentityCredentialFromComponents(trustDomain *TrustDomain, path string) *IdentityCredential
 ```
-- **Post**: `i.path != ""` (always "/" or user-provided non-empty path)
-- **Rationale**: SPIFFE IDs require path component, "/" is valid root
+- **Post**: `i.path != ""` (always "/" or normalized non-empty path)
+- **Post**: Path never contains colon (`:`) - reserved by SPIFFE spec (panics if violated)
+- **Post**: Path never contains `.` or `..` segments - SPIFFE forbids traversal (panics if violated)
+- **Post**: Path has leading slash, no repeated slashes, no trailing slash (except root "/")
+- **Rationale**: SPIFFE IDs require normalized path; colons and dot segments are security risks
 
 ```go
 // Invariant: uri is always formatted as "spiffe://<trustDomain><path>"
@@ -134,13 +137,18 @@ func (i *IdentityCredential) IsInTrustDomain(td *TrustDomain) bool
 #### Invariants:
 
 ```go
-// Invariant: key and value are never empty after construction
-// Location: NewSelector (line 27)
+// Invariant: type, key, and value are validated on construction
+// Location: NewSelector (line 38-93)
 func NewSelector(selectorType SelectorType, key, value string) (*Selector, error)
 ```
-- **Pre**: `key != ""` and `value != ""` (validated, returns error otherwise)
-- **Post**: If `err == nil`, then `s.key != ""` and `s.value != ""` always hold
-- **Rationale**: Empty key/value makes selector meaningless
+- **Pre**: `selectorType != ""`, `key != ""`, `value != ""` (validated, returns error otherwise)
+- **Pre**: `selectorType` must not contain colon (`:`) - reserved separator
+- **Pre**: `key` must not contain colon (`:`) - reserved separator
+- **Post**: If `err == nil`, then:
+  - `s.selectorType != ""` and contains no colons
+  - `s.key != ""` and contains no colons
+  - `s.value != ""` (value MAY contain colons for multi-part values)
+- **Rationale**: Selector format "type:key:value" requires strict parsing; colons in type/key break parsing
 
 ```go
 // Invariant: formatted matches "type:key:value" pattern
@@ -175,36 +183,48 @@ func (s *Selector) Equals(other *Selector) bool
 
 ### 4. `domain.SelectorSet`
 
-**File**: `internal/domain/selector.go`
+**File**: `internal/domain/selector_set.go`
 
 #### Invariants:
 
 ```go
-// Invariant: Set contains no duplicate selectors (uniqueness)
-// Location: Add (line 152)
+// Invariant: Set preserves insertion order and ensures uniqueness
+// Location: Add (line 61-84)
 func (ss *SelectorSet) Add(selector *Selector)
 ```
 - **Pre**: Any selector can be added
 - **Post**: After `Add(s)`, `ss.Contains(s) == true`
-- **Post**: If selector already exists, set size unchanged
+- **Post**: If selector already exists, set size and order unchanged (no-op)
 - **Post**: No two selectors `s1, s2` where `s1.Equals(s2)` exist in set
-- **Rationale**: Set semantics require uniqueness
+- **Post**: Selectors are returned by `All()` in insertion order (deterministic)
+- **Rationale**: Set semantics require uniqueness; order preservation ensures reproducible behavior
+
+```go
+// Invariant: Implementation uses both map and slice for O(1) add/contains
+// Location: SelectorSet struct (line 31-36)
+type SelectorSet struct { seen map[string]struct{}; list []*Selector }
+```
+- **Post**: `seen` map is used for O(1) deduplication checks
+- **Post**: `list` slice preserves insertion order for `All()`
+- **Post**: `len(seen) == len(list)` always holds (both updated atomically in Add)
+- **Rationale**: Combines O(1) operations with deterministic iteration order
 
 ```go
 // Invariant: Contains() never modifies the set
-// Location: Contains (line 159)
+// Location: Contains (line 86-100)
 func (ss *SelectorSet) Contains(selector *Selector) bool
 ```
-- **Post**: Calling `Contains()` never changes `ss.selectors` slice
+- **Post**: Calling `Contains()` never changes `ss.seen` or `ss.list`
 - **Rationale**: Query operation must be side-effect free
 
 ```go
-// Invariant: All() returns defensive copy to prevent external mutation
-// Location: All (line 169)
+// Invariant: All() returns defensive copy in insertion order
+// Location: All (line 126-143)
 func (ss *SelectorSet) All() []*Selector
 ```
-- **Post**: Modifying returned slice does not affect `ss.selectors`
-- **Rationale**: Immutability protection (DDD pattern)
+- **Post**: Modifying returned slice does not affect `ss.list`
+- **Post**: Order matches insertion order (deterministic, reproducible)
+- **Rationale**: Immutability protection (DDD pattern) with predictable iteration
 
 ---
 
@@ -241,12 +261,22 @@ func NewIdentityDocumentFromComponents(...) *IdentityDocument
 - **Rationale**: JWT documents don't use X.509 certificates
 
 ```go
-// Invariant: IsExpired() iff time.Now().After(expiresAt)
-// Location: IsExpired (line 92)
+// Invariant: IsExpired() delegates to IsExpiredAt(time.Now())
+// Location: IsExpired (line 244-258)
 func (id *IdentityDocument) IsExpired() bool
 ```
-- **Post**: Returns `true` when current time > `expiresAt`, `false` otherwise
-- **Rationale**: Simple time-based expiration check
+- **Post**: Returns same result as `IsExpiredAt(time.Now())`
+- **Post**: Returns `true` when current time > `cert.NotAfter`, `false` otherwise
+- **Rationale**: Convenience method that uses IsExpiredAt for clock injection
+
+```go
+// Invariant: IsExpiredAt(t) checks expiration at given time (clock injection)
+// Location: IsExpiredAt (line 260-280)
+func (id *IdentityDocument) IsExpiredAt(t time.Time) bool
+```
+- **Post**: Returns `true` when `t.After(cert.NotAfter)`, `false` otherwise
+- **Post**: Does NOT call time.Now() - pure function for testability
+- **Rationale**: Allows injecting time for testing; avoids time.Now() dependency in tests
 
 ```go
 // Invariant: IsValid() == !IsExpired() for current implementation
diff --git a/internal/adapters/outbound/inmemory/agent.go b/internal/adapters/outbound/inmemory/agent.go
index 26fa3b2..e4c960b 100644
--- a/internal/adapters/outbound/inmemory/agent.go
+++ b/internal/adapters/outbound/inmemory/agent.go
@@ -97,7 +97,7 @@ func (a *InMemoryAgent) initializeAgentIdentity(ctx context.Context) error {
 // GetIdentity returns the agent's own identity document.
 func (a *InMemoryAgent) GetIdentity(ctx context.Context) (*domain.IdentityDocument, error) {
 	if a.agentIdentity == nil {
-		return nil, fmt.Errorf("inmemory: %w: agent identity not initialized", domain.ErrAgentUnavailable)
+		return nil, fmt.Errorf("inmemory: %w: agent identity not initialized", ports.ErrAgentUnavailable)
 	}
 	return a.agentIdentity.IdentityDocument, nil
 }
diff --git a/internal/adapters/outbound/inmemory/server.go b/internal/adapters/outbound/inmemory/server.go
index cd0bbc9..218858a 100644
--- a/internal/adapters/outbound/inmemory/server.go
+++ b/internal/adapters/outbound/inmemory/server.go
@@ -69,12 +69,12 @@ func (s *InMemoryServer) IssueIdentity(ctx context.Context, identityCredential *
 	}
 
 	if s.caCert == nil || s.caKey == nil {
-		return nil, fmt.Errorf("inmemory: %w: CA not initialized", domain.ErrCANotInitialized)
+		return nil, fmt.Errorf("inmemory: %w: CA not initialized", ports.ErrCANotInitialized)
 	}
 
 	doc, err := s.certificateProvider.CreateX509IdentityDocument(ctx, identityCredential, s.caCert, s.caKey)
 	if err != nil {
-		return nil, fmt.Errorf("inmemory: %w: %w", domain.ErrServerUnavailable, err)
+		return nil, fmt.Errorf("inmemory: %w: %w", ports.ErrServerUnavailable, err)
 	}
 
 	return doc, nil
diff --git a/internal/adapters/outbound/spire/identity_provider.go b/internal/adapters/outbound/spire/identity_provider.go
index 26bcf67..0136d02 100644
--- a/internal/adapters/outbound/spire/identity_provider.go
+++ b/internal/adapters/outbound/spire/identity_provider.go
@@ -5,6 +5,7 @@ import (
 	"fmt"
 
 	"github.com/pocket/hexagon/spire/internal/domain"
+	"github.com/pocket/hexagon/spire/internal/ports"
 	"github.com/spiffe/go-spiffe/v2/spiffeid"
 	"github.com/spiffe/go-spiffe/v2/svid/x509svid"
 	"github.com/spiffe/go-spiffe/v2/workloadapi"
@@ -24,7 +25,7 @@ import (
 //  3. Else → pick lexicographically smallest ID from all SVIDs (fallback)
 //
 // Error handling:
-//   - Returns domain.ErrAgentUnavailable for nil/uninitialized client
+//   - Returns ports.ErrAgentUnavailable for nil/uninitialized client
 //   - Returns domain.ErrNoAttestationData when Workload API returns no SVIDs
 //   - Wraps all SDK errors with %w for errors.Is/As compatibility
 //
@@ -33,7 +34,7 @@ import (
 func (c *SPIREClient) FetchX509SVID(ctx context.Context) (*domain.IdentityDocument, error) {
 	// Guard: ensure client is initialized
 	if c == nil || c.client == nil {
-		return nil, fmt.Errorf("%w: SPIRE client is not initialized", domain.ErrAgentUnavailable)
+		return nil, fmt.Errorf("%w: SPIRE client is not initialized", ports.ErrAgentUnavailable)
 	}
 
 	// Defensive: handle nil context
diff --git a/internal/domain/errors.go b/internal/domain/errors.go
index e4bea04..2e4cdc0 100644
--- a/internal/domain/errors.go
+++ b/internal/domain/errors.go
@@ -105,20 +105,20 @@ var (
 	ErrInvalidProcessIdentity = errors.New("invalid process identity")
 )
 
-// Server and agent errors
-var (
-	// ErrServerUnavailable indicates SPIRE server is unavailable.
-	// Used by: Server.IssueIdentity
-	ErrServerUnavailable = errors.New("server unavailable")
-
-	// ErrAgentUnavailable indicates SPIRE agent is unavailable.
-	// Used by: Agent.FetchIdentityDocument, SPIREClient.FetchX509SVID
-	ErrAgentUnavailable = errors.New("agent unavailable")
-
-	// ErrCANotInitialized indicates CA certificate is not initialized.
-	// Used by: Server.GetCA, Server.IssueIdentity
-	ErrCANotInitialized = errors.New("CA not initialized")
-)
+// REMOVED: Infrastructure errors moved to internal/ports/errors.go
+//
+// The following errors have been moved per architecture review (docs/5.md):
+//   - ErrServerUnavailable → ports.ErrServerUnavailable
+//   - ErrAgentUnavailable → ports.ErrAgentUnavailable
+//   - ErrCANotInitialized → ports.ErrCANotInitialized
+//
+// Rationale: These represent infrastructure/adapter concerns, not domain concepts.
+// Domain errors should be semantic/business failures only.
+//
+// Adapters should use ports.Err* variants. If infrastructure errors need to be
+// surfaced to application layer, adapters can wrap them with domain errors when
+// they have domain meaning (e.g., wrap ports.ErrAgentUnavailable with
+// ErrNoAttestationData if attestation fails due to agent being down).
 
 // Entity validation errors
 var (
@@ -194,9 +194,8 @@ var (
 	_ error = ErrWorkloadAttestationFailed
 	_ error = ErrNoAttestationData
 	_ error = ErrInvalidProcessIdentity
-	_ error = ErrServerUnavailable
-	_ error = ErrAgentUnavailable
-	_ error = ErrCANotInitialized
+	// Removed: ErrServerUnavailable, ErrAgentUnavailable, ErrCANotInitialized
+	// (moved to ports.Err* - see ports/errors.go)
 	_ error = ErrIdentityMapperInvalid
 	_ error = ErrWorkloadInvalid
 	_ error = ErrNotSupported
diff --git a/internal/domain/identity_credential.go b/internal/domain/identity_credential.go
index 47005ba..59d3b20 100644
--- a/internal/domain/identity_credential.go
+++ b/internal/domain/identity_credential.go
@@ -91,6 +91,8 @@ func NewIdentityCredentialFromComponents(trustDomain *TrustDomain, path string)
 //  3. Ensure leading slash (e.g., "foo" → "/foo")
 //  4. Collapse multiple slashes (e.g., "//foo//bar" → "/foo/bar")
 //  5. Remove trailing slashes (e.g., "/foo/bar/" → "/foo/bar")
+//  6. Reject paths with colons (`:`) - reserved by SPIFFE spec
+//  7. Reject dot (`.`) and dotdot (`..`) segments - SPIFFE forbids these
 //
 // This ensures canonical representation for equality checks and prevents
 // duplicate identities like "/foo" and "//foo" from being treated differently.
@@ -105,6 +107,10 @@ func NewIdentityCredentialFromComponents(trustDomain *TrustDomain, path string)
 //   normalizePath("///foo///")    → "/foo"
 //   normalizePath("/foo/bar/")    → "/foo/bar"
 //
+// Panics:
+//   - If path contains colon (`:`) - reserved character
+//   - If path contains `.` or `..` segments - SPIFFE forbids traversal
+//
 // Note: Query parameters and fragments are not handled here as they're
 // invalid in SPIFFE IDs. Adapters using go-spiffe SDK reject such inputs
 // during parsing.
@@ -117,23 +123,36 @@ func normalizePath(p string) string {
 		return "/"
 	}
 
-	// Step 3: Ensure leading slash
+	// Step 3: Validate no colons (reserved by SPIFFE spec)
+	if strings.Contains(p, ":") {
+		panic(fmt.Errorf("%w: path cannot contain colon ':' (reserved character)", ErrInvalidIdentityCredential))
+	}
+
+	// Step 4: Ensure leading slash
 	if !strings.HasPrefix(p, "/") {
 		p = "/" + p
 	}
 
-	// Step 4: Collapse repeated slashes
+	// Step 5: Collapse repeated slashes
 	// Loop instead of regex for simplicity and no regex dependency
 	for strings.Contains(p, "//") {
 		p = strings.ReplaceAll(p, "//", "/")
 	}
 
-	// Step 5: Remove trailing slashes (but preserve root "/")
+	// Step 6: Remove trailing slashes (but preserve root "/")
 	p = strings.TrimRight(p, "/")
 	if p == "" {
 		return "/"
 	}
 
+	// Step 7: Validate no dot or dotdot segments (SPIFFE forbids traversal)
+	segments := strings.Split(p, "/")
+	for _, seg := range segments {
+		if seg == "." || seg == ".." {
+			panic(fmt.Errorf("%w: path cannot contain '.' or '..' segments", ErrInvalidIdentityCredential))
+		}
+	}
+
 	return p
 }
 
diff --git a/internal/domain/identity_document.go b/internal/domain/identity_document.go
index c5b0ac6..5de9b5b 100644
--- a/internal/domain/identity_document.go
+++ b/internal/domain/identity_document.go
@@ -15,6 +15,17 @@ import (
 //   - Private key: crypto.Signer for mTLS and signing operations
 //   - Chain: Certificate chain (leaf-first)
 //
+// TODO(architecture): Private key (crypto.Signer) should be removed from domain entity
+// per docs/5.md review. Domain should be purely descriptive (identity, cert, chain, times).
+// Adapters should hold the signer or return (doc, signer) tuple. This is a breaking change:
+//   1. Remove privateKey field from IdentityDocument struct
+//   2. Remove PrivateKey() method
+//   3. Update NewIdentityDocumentFromComponents to not accept privateKey parameter
+//   4. Update all adapters to return (doc, signer) separately or use adapter-level key storage
+//   5. Update all uses of doc.PrivateKey() to get key from adapter layer
+// Rationale: Keeps domain free of sensitive/opaque infrastructure concerns, simplifies
+// serialization and testing, and follows clean architecture principles.
+//
 // Design Philosophy:
 //   - Immutable: All fields validated once at construction, never modified
 //   - Defensive: Chain is copied on read/write to prevent aliasing bugs
@@ -246,12 +257,37 @@ func (id *IdentityDocument) Remaining() time.Duration {
 // This is a simple time comparison without clock skew handling.
 // For production use with clock skew tolerance, use IsCurrentlyValid(skew).
 //
+// Note: This method calls time.Now() internally. For testability,
+// use IsExpiredAt(t) which accepts an explicit time parameter.
+//
 // Example:
 //   if id.IsExpired() {
 //       // Need to rotate certificate
 //   }
 func (id *IdentityDocument) IsExpired() bool {
-	return time.Now().After(id.ExpiresAt())
+	return id.IsExpiredAt(time.Now())
+}
+
+// IsExpiredAt reports whether the document is past its NotAfter time at a given time.
+//
+// This method allows injecting the clock for testing and avoids time.Now()
+// dependency in domain logic. Use this in tests to control time.
+//
+// Parameters:
+//   - t: The time to check expiration against
+//
+// Returns:
+//   - true if t is after the document's expiration time
+//   - false if t is before or equal to the expiration time
+//
+// Example:
+//   // In tests
+//   testTime := time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC)
+//   if id.IsExpiredAt(testTime) {
+//       // Document expired at test time
+//   }
+func (id *IdentityDocument) IsExpiredAt(t time.Time) bool {
+	return t.After(id.ExpiresAt())
 }
 
 // IsValid checks if the identity document is currently valid (not expired).
diff --git a/internal/domain/selector.go b/internal/domain/selector.go
index 6a795bd..800a953 100644
--- a/internal/domain/selector.go
+++ b/internal/domain/selector.go
@@ -42,8 +42,13 @@ type Selector struct {
 //   - key: The selector attribute name (e.g., "uid", "namespace")
 //   - value: The selector attribute value (e.g., "1000", "default")
 //
+// Validation:
+//   - selectorType must not be empty
+//   - key must not be empty and must not contain colon (`:`)
+//   - value must not be empty (value MAY contain colons for multi-part values)
+//
 // Returns:
-//   - ErrSelectorInvalid (with context) if key or value is empty
+//   - ErrSelectorInvalid (with context) if validation fails
 //
 // Example:
 //   selector, err := NewSelector(SelectorTypeWorkload, "uid", "1000")
@@ -52,13 +57,32 @@ type Selector struct {
 //   }
 //   // selector.String() == "workload:uid:1000"
 func NewSelector(selectorType SelectorType, key, value string) (*Selector, error) {
+	// Validate type is not empty
+	if string(selectorType) == "" {
+		return nil, fmt.Errorf("%w: selector type is empty", ErrSelectorInvalid)
+	}
+
+	// Validate type does not contain colon
+	if strings.Contains(string(selectorType), ":") {
+		return nil, fmt.Errorf("%w: selector type cannot contain colon ':', got %q", ErrSelectorInvalid, selectorType)
+	}
+
+	// Validate key is not empty
 	if key == "" {
 		return nil, fmt.Errorf("%w: key is empty", ErrSelectorInvalid)
 	}
+
+	// Validate key does not contain colon
+	if strings.Contains(key, ":") {
+		return nil, fmt.Errorf("%w: key cannot contain colon ':', got %q", ErrSelectorInvalid, key)
+	}
+
+	// Validate value is not empty (value MAY contain colons)
 	if value == "" {
 		return nil, fmt.Errorf("%w: value is empty", ErrSelectorInvalid)
 	}
 
+	// Pre-compute formatted string once for goroutine-safe immutability
 	formatted := fmt.Sprintf("%s:%s:%s", selectorType, key, value)
 	return &Selector{
 		selectorType: selectorType,
diff --git a/internal/domain/selector_set.go b/internal/domain/selector_set.go
index 63be51c..d8acb54 100644
--- a/internal/domain/selector_set.go
+++ b/internal/domain/selector_set.go
@@ -2,8 +2,17 @@
 
 package domain
 
-// SelectorSet represents a collection of unique selectors.
-// Provides O(1) add/contains operations using map-based storage.
+// SelectorSet represents an order-preserving collection of unique selectors.
+//
+// Implementation:
+//   - Uses map[string]struct{} for O(1) deduplication (keyed by formatted selector)
+//   - Uses []Selector slice to preserve insertion order
+//   - All() returns selectors in insertion order (deterministic, unlike pure map iteration)
+//
+// Time complexity:
+//   - Add(): O(1)
+//   - Contains(): O(1)
+//   - All(): O(n) where n is the number of selectors
 //
 // Thread-safety: SelectorSet is NOT thread-safe. Callers must synchronize access.
 //
@@ -18,13 +27,17 @@ package domain
 //   if set.Contains(selector1) {
 //       // Process matching selector
 //   }
+//   all := set.All() // Returns selectors in insertion order
 type SelectorSet struct {
-	// Map key is the formatted selector string for O(1) lookup
-	selectors map[string]*Selector
+	// Map for O(1) deduplication check
+	seen map[string]struct{}
+	// Slice to preserve insertion order
+	list []*Selector
 }
 
 // NewSelectorSet creates a new selector set with the given selectors.
 // Nil selectors are ignored. Duplicates are automatically deduplicated.
+// Selectors are added in the order provided (insertion order preserved).
 //
 // Time complexity: O(n) where n is the number of input selectors
 //
@@ -33,19 +46,22 @@ type SelectorSet struct {
 //   s2, _ := ParseSelectorFromString("workload:user:app")
 //   set := NewSelectorSet(s1, s2)
 //   // set.Len() == 2
+//   // set.All() returns [s1, s2] in that order
 func NewSelectorSet(selectors ...*Selector) *SelectorSet {
-	ss := &SelectorSet{selectors: make(map[string]*Selector)}
+	ss := &SelectorSet{
+		seen: make(map[string]struct{}),
+		list: make([]*Selector, 0, len(selectors)),
+	}
 	for _, s := range selectors {
-		if s != nil {
-			ss.selectors[s.formatted] = s
-		}
+		ss.Add(s) // Use Add to ensure deduplication and ordering
 	}
 	return ss
 }
 
 // Add adds a selector to the set.
-// Ensures uniqueness - duplicates overwrite existing entries.
+// Ensures uniqueness - duplicates are ignored (no-op).
 // Nil selectors are ignored.
+// Preserves insertion order for All().
 //
 // Time complexity: O(1)
 //
@@ -53,9 +69,18 @@ func NewSelectorSet(selectors ...*Selector) *SelectorSet {
 //   set.Add(selector)
 //   set.Add(selector) // No-op, already exists
 func (ss *SelectorSet) Add(selector *Selector) {
-	if selector != nil {
-		ss.selectors[selector.formatted] = selector
+	if selector == nil {
+		return
 	}
+
+	// Check if already exists
+	if _, exists := ss.seen[selector.formatted]; exists {
+		return // Already in set, maintain original order
+	}
+
+	// Add to both map and list
+	ss.seen[selector.formatted] = struct{}{}
+	ss.list = append(ss.list, selector)
 }
 
 // Contains checks if the set contains a selector.
@@ -71,7 +96,7 @@ func (ss *SelectorSet) Contains(selector *Selector) bool {
 	if selector == nil {
 		return false
 	}
-	_, ok := ss.selectors[selector.formatted]
+	_, ok := ss.seen[selector.formatted]
 	return ok
 }
 
@@ -82,7 +107,7 @@ func (ss *SelectorSet) Contains(selector *Selector) bool {
 // Example:
 //   count := set.Len()
 func (ss *SelectorSet) Len() int {
-	return len(ss.selectors)
+	return len(ss.list)
 }
 
 // IsEmpty returns true if the set contains no selectors.
@@ -95,14 +120,14 @@ func (ss *SelectorSet) Len() int {
 //       return ErrNoSelectors
 //   }
 func (ss *SelectorSet) IsEmpty() bool {
-	return len(ss.selectors) == 0
+	return len(ss.list) == 0
 }
 
-// All returns all selectors as a slice.
-// Returns a new slice to prevent external mutation (DDD immutability).
+// All returns all selectors as a slice in insertion order.
+// Returns a defensive copy to prevent external mutation (DDD immutability).
 //
-// The order of selectors is non-deterministic due to map iteration order.
-// If you need deterministic ordering, sort the result after calling All().
+// Order is deterministic: selectors are returned in the order they were added.
+// This ensures consistent, reproducible behavior across runs.
 //
 // Time complexity: O(n) where n is the number of selectors
 //
@@ -111,18 +136,17 @@ func (ss *SelectorSet) IsEmpty() bool {
 //       fmt.Println(selector)
 //   }
 func (ss *SelectorSet) All() []*Selector {
-	result := make([]*Selector, 0, len(ss.selectors))
-	for _, s := range ss.selectors {
-		result = append(result, s)
-	}
+	// Return defensive copy to prevent external mutation
+	result := make([]*Selector, len(ss.list))
+	copy(result, ss.list)
 	return result
 }
 
-// Strings returns all selectors as formatted strings.
+// Strings returns all selectors as formatted strings in insertion order.
 // Useful for logging, serialization, or displaying selector sets.
 //
-// The order of strings is non-deterministic due to map iteration order.
-// If you need deterministic ordering, sort the result after calling Strings().
+// Order is deterministic: selectors are returned in the order they were added.
+// This ensures consistent, reproducible behavior across runs.
 //
 // Time complexity: O(n) where n is the number of selectors
 //
@@ -130,9 +154,9 @@ func (ss *SelectorSet) All() []*Selector {
 //   log.Printf("Selectors: %v", set.Strings())
 //   // Output: Selectors: [workload:uid:1000 workload:user:app]
 func (ss *SelectorSet) Strings() []string {
-	result := make([]string, 0, len(ss.selectors))
-	for formatted := range ss.selectors {
-		result = append(result, formatted)
+	result := make([]string, 0, len(ss.list))
+	for _, s := range ss.list {
+		result = append(result, s.formatted)
 	}
 	return result
 }
diff --git a/internal/ports/outbound_dev.go b/internal/ports/outbound_dev.go
index e03cf14..d3a95ca 100644
--- a/internal/ports/outbound_dev.go
+++ b/internal/ports/outbound_dev.go
@@ -53,8 +53,8 @@ type WorkloadAttestor interface {
 //
 // Error Contract:
 // - IssueIdentity: domain.ErrIdentityDocumentInvalid if identity credential invalid
-// - IssueIdentity: domain.ErrServerUnavailable if server unavailable
-// - IssueIdentity: domain.ErrCANotInitialized if CA not initialized
+// - IssueIdentity: ports.ErrServerUnavailable if server unavailable
+// - IssueIdentity: ports.ErrCANotInitialized if CA not initialized
 // - GetTrustDomain: never returns error (returns nil if not initialized)
 // - GetCACertPEM:  returns empty slice if CA not initialized
 //
@@ -77,7 +77,7 @@ type IdentityServer interface {
 //
 // Error Contract:
 // - CreateX509IdentityDocument: domain.ErrIdentityDocumentInvalid for invalid inputs
-// - CreateX509IdentityDocument: domain.ErrCANotInitialized if CA not available
+// - CreateX509IdentityDocument: ports.ErrCANotInitialized if CA not available
 //
 // Implementations should respect ctx cancellation where applicable.
 type IdentityDocumentCreator interface {
