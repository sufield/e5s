## Critical fixes

### 1) Client example won’t compile

* Missing `net/http` import.
* You import `go-spiffe` in the client example, but your `httpclient` adapter is supposed to hide SDK details. Keep examples consistent: either use your adapter **only**, or show a raw SDK example (not both).

**Fixed client example (uses your adapter only):**

```go
package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/http" // ← missing
	"time"

	"github.com/pocket/hexagon/spire/internal/adapters/outbound/httpclient"
	"github.com/pocket/hexagon/spire/internal/ports"
)

func main() {
	ctx := context.Background()

	var cfg ports.MTLSConfig
	cfg.WorkloadAPI.SocketPath = "unix:///tmp/spire-agent/public/api.sock"
	// Either pin an exact SPIFFE ID:
	cfg.SPIFFE.AllowedPeerID = "spiffe://example.org/server"
	// or allow a trust domain:
	// cfg.SPIFFE.AllowedTrustDomain = "example.org"

	client, err := httpclient.New(ctx, cfg)
	if err != nil {
		log.Fatalf("Failed to create client: %v", err)
	}
	defer client.Close()

	req, _ := http.NewRequestWithContext(ctx, http.MethodGet, "https://localhost:8443/api/hello", nil)
	resp, err := client.Do(ctx, req)
	if err != nil {
		log.Fatalf("Request failed: %v", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	fmt.Printf("Response: %s\n", body)
}
```

> If you want a **raw go-spiffe** client example, remove your `httpclient` import and show the SDK setup (source + tlsconfig) end-to-end.

### 2) `IdentityDocument` in the domain contains a private key

Your doc shows:

```go
type IdentityDocument struct {
    identityCredential *IdentityCredential
    certificate        *x509.Certificate
    privateKey         crypto.PrivateKey
    certificateChain   []*x509.Certificate
    expiresAt          time.Time
}
```

Keeping the **private key** in the domain leaks infrastructure concerns and complicates testing, equality, and persistence.

**Correction:** keep the domain doc **descriptive only** (identity + leaf + chain + validity). Hold the signer/key in the adapter layer (or return it as a separate opaque handle alongside the domain object).

### 3) “TLS 1.3 enforced” claim

The doc claims minimum TLS 1.3. That’s only correct if your `identityserver` adapter sets:

```go
tlsConfig := &tls.Config{
    MinVersion: tls.VersionTLS13,
    // …
}
```

If it does not, either add it or change the claim to “TLS 1.3 by default when supported”.

### 4) Port names and locations

You say `MTLSClient` is in `internal/ports/identityserver.go`. That file name suggests server concerns. Keep the doc accurate (or split into `identityserver.go` + `httpclient.go`, or a neutral `mtls.go`).

### 5) Hostname/SANs in examples

The client uses `https://server:8443` or `https://localhost:8443`. The server’s SVID must include a matching DNS SAN (or the client must use SPIFFE authorization without relying on DNS name for TLS hostname verification, depending on your adapter). Your Quick Start elsewhere already adds `localhost` SANs—be consistent here too.

## API/docs tightening

### Config precedence and validation

Document this clearly:

* If both `AllowedPeerID` and `AllowedTrustDomain` are set, **AllowedPeerID takes precedence**.
* Validate:

  * `SocketPath` non-empty, with `unix://` scheme (or document accepted forms).
  * Exactly one of `AllowedPeerID` / `AllowedTrustDomain` may be empty; both empty is **deny-all** or **error** (choose and document).
* Server defaults (timeouts) should be listed with actual values used in code.

### Identity in context

You show:

```go
func IdentityFrom(ctx context.Context) (Identity, bool)
func WithIdentity(ctx context.Context, id Identity) context.Context
```

Good. Ensure:

* `Identity` is immutable (exported fields are fine; just don’t mutate after injection).
* Handlers must handle `(false)` and return `401`.

### Domain invariants (match the code)

You reference invariants and `INVARIANTS.md`. Make sure the constructors enforce:

* `IdentityCredential`: non-nil trust domain; normalized path (`"/"` root, otherwise `"/"+trim("/")`).
* `Selector`: strict `type:key:value` (value may contain `:`; type/key may not).
* `SelectorSet`: order-preserving dedup (map+slice) and defensive copies.
* `IdentityDocument`: defensive copy of chain; leaf is chain[0]; **no private key**.

## Security checks to implement (or confirm)

* **TLS MinVersion** = TLS1.3 (as claimed).
* **Mutual auth**: server verifies client SPIFFE `AllowedPeerID` or `AllowedTrustDomain`; client verifies server identity similarly.
* **Close/Shutdown**: server uses graceful shutdown with `Shutdown(ctx)` + timeouts; closes Workload API sources (adapters).
* **Zero-downtime rotation**: confirm listeners reuse `tls.Config.GetCertificate`/`GetClientCertificate` with `workloadapi.X509Source` so rotations don’t restart the server.

## Example corrections (server)

Your server example is fine, just add an explicit health handler and make the identity extraction path crystal-clear:

```go
server.Handle("/api/hello", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	id, ok := ports.IdentityFrom(r.Context())
	if !ok {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}
	fmt.Fprintf(w, "Hello, %s!\n", id.SPIFFEID)
}))

server.Handle("/health", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write([]byte(`{"status":"ok"}`))
}))
```

## Small but helpful improvements

* **Time source** in domain: prefer `IsExpiredAt(t time.Time)` and keep `IsExpired()` as a thin wrapper to reduce test flakiness.
* **Adapter error mapping**: keep infra errors (e.g., “server unavailable”, “CA not initialized”) in adapters/ports, not in the domain error set.
* **Docs consistency**: your dir tree lists `controlplane/` and `compose/`; keep it in sync with the repo or mark as “optional/example”.
* **Kubernetes socket path**: when users test in-cluster, remind them the Workload API socket must be **mounted** and `SPIFFE_ENDPOINT_SOCKET` must point to that mount (you did this in other docs; add a one-liner here).


* Fix the **client example** (imports + consistent adapter usage).
* Remove the **private key from the domain entity**.
* Either **enforce TLS 1.3** in code or tone down the claim.
* Document **config precedence** and validation.
* Ensure path and selector **invariants** are enforced in constructors.

Apply these and the doc will accurately reflect a production-ready, hexagonal mTLS library with clean boundaries and correct examples.
