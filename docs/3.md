Your two runners cover both day-to-day iteration (Debian) and hardened CI (distroless). Below are the most important correctness fixes and small upgrades so they’re rock-solid and faster.

## High-impact fixes

### 1) Distroless + `kubectl cp` always needs a helper container

* `kubectl cp` relies on `tar` inside the target container. Distroless has no shell/tar, so the initial attempt to copy into `-c test` will fail intermittently (or always, depending on kubectl/server versions).
* You already fall back to an `initContainer` with BusyBox when the copy fails; make this the **primary path** to avoid flakiness.

**Action:** Always define an `initContainer` (BusyBox or scratch-with-tar) that:

* waits until `/work/integration.test` appears (copied by `kubectl cp -c setup`),
* `chmod +x` on it,
* then exits so the distroless container starts and executes the test.

**Init command example (deterministic):**

```yaml
initContainers:
  - name: setup
    image: busybox:stable-musl
    command: ["sh","-c","while [ ! -f /work/integration.test ]; do sleep 0.2; done; chmod +x /work/integration.test"]
    volumeMounts:
      - name: work
        mountPath: /work
```

Then always:

```bash
kubectl cp "$TESTBIN" "$NS/$POD_NAME":/work/integration.test -c setup
```

### 2) Don’t wait for **Ready** on a short-lived test pod

* The distroless pod runs the test and exits. Completed pods usually **don’t report Ready=true**; `kubectl wait --for=condition=Ready` will often time out.
* Instead, wait for **PodScheduled**, then stream logs, then check container **terminated exitCode** (or pod phase).

**Drop-in snippet:**

```bash
# after kubectl apply …
kubectl wait --for=condition=PodScheduled pod/"$POD_NAME" -n "$NS" --timeout=60s >/dev/null

# stream logs until container exits
kubectl logs -n "$NS" "$POD_NAME" -f || true

# determine exit code precisely
EXIT_CODE="$(kubectl get pod -n "$NS" "$POD_NAME" -o jsonpath='{.status.containerStatuses[?(@.name=="test")].state.terminated.exitCode}')"
if [ -z "$EXIT_CODE" ]; then
  # fallback: phase check
  PHASE="$(kubectl get pod -n "$NS" "$POD_NAME" -o jsonpath='{.status.phase}')"
  EXIT_CODE=$([ "$PHASE" = "Succeeded" ] && echo 0 || echo 1)
fi
exit "$EXIT_CODE"
```

### 3) Cross-arch build (Minikube on Apple Silicon, etc.)

* Compile for the cluster’s node architecture, not always `amd64`.

**Auto-detect GOARCH from the node:**

```bash
NODE_ARCH=$(kubectl get nodes -o jsonpath='{.items[0].status.nodeInfo.architecture}')
GOARCH="${GOARCH:-$NODE_ARCH}"   # allow override
CGO_ENABLED=0 GOOS=linux GOARCH="$GOARCH" \
  go test -tags="$TAGS" -c -o "$TESTBIN" "$PKG"
```

### 4) Host socket existence check (early failure)

Before creating the pod, verify the hostPath directory exists on the node:

```bash
# pick the node (minikube is single-node)
NODE="$(kubectl get nodes -o jsonpath='{.items[0].metadata.name}')"
if ! minikube ssh -- "test -S ${SOCKET_DIR}/${SOCKET_FILE} -o -d ${SOCKET_DIR}" >/dev/null 2>&1; then
  echo "Socket or directory not present on node: ${SOCKET_DIR}/${SOCKET_FILE}"
  exit 1
fi
```

(If you’re not using minikube’s SSH in CI, provide a kube DaemonSet probe or skip this check.)

---

## Lower-risk improvements

### 5) Safer agent pod detection

Your tolerant selector is good; add a third common label as last resort:

```bash
AGENT_POD=$(
  kubectl get pods -n "$NS" -l 'app.kubernetes.io/name=agent' -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || \
  kubectl get pods -n "$NS" -l 'app=spire-agent' -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || \
  kubectl get pods -n "$NS" -l 'name=spire-agent' -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || \
  true
)
```

### 6) Distroless security context is solid

* You set `runAsNonRoot`, `fsGroup`, and drop all caps. Good.
* Keep `readOnlyRootFilesystem: true`. It’s already there.

### 7) Debian runner (optimized script)

* Your Debian script waits for **Ready** (ok because it’s `sleep infinity`), copies the binary, `chmod +x`, then `exec` runs the test. That flow is fine.
* For repeat runs, `KEEP=true` is useful. Consider also a `RECREATE=false` flag for “apply if missing”.

### 8) Consistent env naming

* Use **`SPIFFE_ENDPOINT_SOCKET`** everywhere. You already do; keep it consistent with your library.

---

## Cleaned distroless YAML (final form)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: ${POD_NAME}
  namespace: ${NS}
  labels:
    app: spire-integration-test
    role: ci-test
spec:
  restartPolicy: Never
  securityContext:
    runAsNonRoot: true
    runAsUser: 65532
    fsGroup: 65532
    seccompProfile:
      type: RuntimeDefault
  volumes:
    - name: spire-socket
      hostPath:
        path: ${SOCKET_DIR}
        type: Directory
    - name: work
      emptyDir: {}
  initContainers:
    - name: setup
      image: busybox:stable-musl
      command: ["sh","-c","while [ ! -f /work/integration.test ]; do sleep 0.2; done; chmod +x /work/integration.test"]
      volumeMounts:
        - name: work
          mountPath: /work
  containers:
    - name: test
      image: gcr.io/distroless/static-debian12:nonroot
      command: ["/work/integration.test"]
      args: ["-test.v"]
      env:
        - name: SPIFFE_ENDPOINT_SOCKET
          value: "unix:///spire-socket/${SOCKET_FILE}"
        - name: SPIRE_TRUST_DOMAIN
          value: "${TRUST_DOMAIN}"
      volumeMounts:
        - name: spire-socket
          mountPath: /spire-socket
          readOnly: true
        - name: work
          mountPath: /work
      resources:
        requests: { cpu: "100m", memory: "128Mi" }
        limits:   { cpu: "500m", memory: "256Mi" }
      securityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities: { drop: ["ALL"] }
```

**Copy step (always to `-c setup`):**

```bash
kubectl apply -f "$POD_YAML" >/dev/null
kubectl wait --for=condition=PodScheduled pod/"$POD_NAME" -n "$NS" --timeout=60s >/dev/null
kubectl cp "$TESTBIN" "$NS/$POD_NAME":/work/integration.test -c setup
# no chmod via exec needed; initContainer does it, then exits
```

**Run & result:**

```bash
kubectl logs -n "$NS" "$POD_NAME" -f || true
EXIT_CODE="$(kubectl get pod -n "$NS" "$POD_NAME" -o jsonpath='{.status.containerStatuses[?(@.name=="test")].state.terminated.exitCode}')"
[ -z "$EXIT_CODE" ] && EXIT_CODE=1
exit "$EXIT_CODE"
```

* **Always** copy into an init container for distroless (no tar), then start the test container.
* **Don’t wait for Ready** on a one-shot test pod; **wait scheduled → logs → terminated exitCode**.
* **Build for the cluster arch** (auto-detect GOARCH).
* Keep the Debian script for iteration; use the distroless script in CI.
