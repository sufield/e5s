## What’s correct (keep)

* Clear hexagonal split: **domain ↔ ports ↔ adapters** with an anti-corruption layer.
* **Domain is SDK-agnostic** (no go-spiffe types). Good.
* **Value objects vs entities** separation is consistent.
* Using only **stdlib** (e.g., `crypto/x509`, `crypto.Signer`) in domain is acceptable.
* Dev-only identity mapper behind a **`//go:build dev`** tag is a sound teaching tool.
* Translation functions live in adapters, not domain. Good.

## Gaps / corrections

### 1) Private key inside the domain entity

You store `crypto.Signer` in `IdentityDocument`. That leaks sensitive/opaque key material into the domain layer and complicates serialization, equality, and testing.

**Fix (recommended):**

* Keep domain **document** purely descriptive (identity, leaf cert, chain, validity times).
* Let adapters hold the signer or a **key handle** (opaque reference) at the infrastructure layer.
* If you must keep a signer in domain, make the type an interface the domain does **not** depend on (port), or store only a key **ID**.

```go
// domain: no private key
type IdentityDocument struct {
    id     *IdentityCredential
    leaf   *x509.Certificate
    chain  []*x509.Certificate
    // no signer here
}
```

Adapters can return `(doc *domain.IdentityDocument, signer crypto.Signer)` together.

### 2) Time dependency in domain

`IsExpired()` presumably calls `time.Now()`. That makes time hard to test and can create flakiness.

**Fix:**

* Inject a **clock** (small interface) or accept a time at call-site: `IsExpiredAt(t time.Time)`; keep `IsExpired()` as a thin wrapper around `IsExpiredAt(time.Now())`.

### 3) Identity parsing responsibility

You say parsing is delegated to an `IdentityCredentialParser` **port**, but later your adapter translation calls `domain.NewIdentityCredentialFromComponents(...)` directly. That’s fine, but ensure **domain constructors enforce invariants** (e.g., path normalization), otherwise adapters must sanitize.

**Fix:**

* In `NewIdentityCredentialFromComponents(td, path)`:

  * require `td != nil`
  * normalize path: `"/"` for empty; `"/" + strings.Trim(path, "/")` for non-root
  * reject paths with `:` or invalid runes per SPIFFE spec (at least basic checks)
* Document that adapters may perform **strict** spec validation; domain enforces **minimal** safety.

### 4) SPIFFE path edge cases

Your adapter example:

```go
if identityCredential.Path() == "/" {
    return spiffeid.FromSegments(sdkTD) // root
}
segments := segmentsFromPath(identityCredential.Path())
return spiffeid.FromSegments(sdkTD, segments...)
```

**Ensure `segmentsFromPath` is correct:**

* Trim leading slash.
* Reject empty path segments except the root case.
* Reject `.`/`..` segments (SPIFFE forbids).
* Preserve percent-encoding rules if you support them (or document you don’t).

### 5) Selector formatting and parsing

You state “multi-colon value parsing with `strings.Join()`”. That’s good, but pin down rules:

* Allowed format: `type:key:value` where **value** may contain colons.
* Type & key **must not** contain `:` and must be non-empty.
* Cache of `Formatted()` should be built **once** on construction so it’s goroutine-safe without locks (object is immutable).

**Fix:**

* Validate `type` and `key` are ASCII, non-empty, no `:`.
* `ParseSelectorFromString()` should split into 3 parts only: `type`, `key`, `valueRest`. Return `ErrSelectorInvalid` if malformed.

### 6) SelectorSet “order-preserving set”

You claim order-preserving and deduplicated. That’s fine, but be explicit:

* Use a `map[string]struct{}` (keyed by `Formatted()`) to gate inserts, and a `[]Selector` to preserve insertion order.
* `All()` must return a **copy** of the slice.
* Document complexity of `Add()` O(1), `Contains()` O(1), `All()` O(n).

### 7) Error taxonomy (domain vs infra)

Some sentinel errors feel **infra-ish**:

* `ErrCANotInitialized`, `ErrServerUnavailable` are adapter/infrastructure concerns.
* Domain should prefer semantic errors: `ErrInvalidIdentityDocument`, `ErrNoMatchingMapper`, etc.

**Fix:**

* Keep infra errors **out** of domain (define them in adapters/ports).
* Map infra errors to domain errors only if they have domain meaning; otherwise, return wrapped infra errors at the port boundary.

### 8) Ports referencing DTOs / frameworks

You show:

```go
type IdentityProvider interface {
    FetchIdentity(ctx context.Context) (*dto.Identity, error)
}
```

But `dto` isn’t defined here and may couple ports to a transport layer.

**Fix:**

* Ports should use **domain types** (or port-level structs). Avoid leaking a `dto` package into ports. Keep DTOs at the **adapter** edge.

Also, `MTLSServer.Handle(pattern string, handler http.Handler)` ties the port to `net/http`. It’s acceptable if your inbound adapter is explicitly HTTP-only, but then this is an **adapter port**, not a generic domain service port. If you want transport-agnostic ports, expose a request/response abstraction and let the HTTP adapter implement it.

### 9) “Standard library only” claim

You correctly allow `crypto/x509`. Note: x509 parsing/verification beyond basic fields belongs in adapters (you wrote that, good). Keep **document validation** that requires chain verification out of domain.

### 10) INVARIANTS.md references

You refer to `INVARIANTS.md`. Ensure it exists and covers:

* IdentityCredential: TD non-nil; normalized path; stable `.String()`; equality contract.
* Selector/Set: format, immutability, set semantics.
* IdentityDocument: chain is defensively copied; leaf is first; validity semantics and clock rule.

## Concrete nits & snippets

### IdentityCredential normalization

```go
func NewIdentityCredentialFromComponents(td *TrustDomain, path string) *IdentityCredential {
    if td == nil { panic("trust domain nil") } // or return error; your choice
    p := strings.TrimSpace(path)
    if p == "" || p == "/" {
        p = "/"
    } else {
        p = "/" + strings.Trim(p, "/")
    }
    // optionally: validateRunes(p) and forbid ":" etc.
    return &IdentityCredential{td: td, path: p}
}
```

### Selector parsing

```go
func ParseSelectorFromString(s string) (Selector, error) {
    first := strings.IndexByte(s, ':')
    if first <= 0 { return Selector{}, ErrSelectorInvalid }
    second := strings.IndexByte(s[first+1:], ':')
    if second < 0 { return Selector{}, ErrSelectorInvalid }
    second += first + 1
    typ := s[:first]
    key := s[first+1 : second]
    val := s[second+1:] // may contain colons
    if typ == "" || key == "" || val == "" { return Selector{}, ErrSelectorInvalid }
    // validate typ/key (no colons, ASCII)
    return NewSelector(SelectorType(typ), key, val)
}
```

### SelectorSet internals

```go
type SelectorSet struct {
    seen map[string]struct{}
    list []Selector
}

func (s *SelectorSet) Add(sel Selector) {
    f := sel.Formatted()
    if _, ok := s.seen[f]; ok { return }
    s.seen[f] = struct{}{}
    s.list = append(s.list, sel)
}

func (s *SelectorSet) All() []Selector {
    out := make([]Selector, len(s.list))
    copy(out, s.list)
    return out
}
```

### IdentityDocument immutability

* Defensive copy of `chain` on construction and when returning.
* Don’t expose internal slices.

```go
func NewIdentityDocumentFromComponents(id *IdentityCredential, leaf *x509.Certificate, chain []*x509.Certificate) *IdentityDocument {
    c := make([]*x509.Certificate, len(chain))
    copy(c, chain)
    return &IdentityDocument{id: id, leaf: leaf, chain: c}
}

func (d *IdentityDocument) Chain() []*x509.Certificate {
    c := make([]*x509.Certificate, len(d.chain))
    copy(c, d.chain)
    return c
}
```

### Domain errors scope

Keep in domain:

* `ErrInvalidIdentityCredential`
* `ErrIdentityDocumentInvalid | …Expired | …Mismatch`
* `ErrInvalidSelectors | ErrNoMatchingMapper`
* `ErrWorkloadInvalid`

Move to adapters/ports:

* `ErrCANotInitialized`, `ErrServerUnavailable`.

* **Main correction:** avoid keeping the **private key** in the domain entity; keep it in adapters (or as an opaque handle).
* **Tighten** domain constructors (normalize/validate path; immutable, defensive copies).
* **Clarify** error boundaries (infra vs domain).
* **Make ports transport-agnostic** unless you consciously define an HTTP-specific inbound port.
* Ensure `INVARIANTS.md` actually exists and matches the doc.

If you apply the above, your domain write-up and contracts will match the code and hold up under edge cases and testing.
