Solid composition-root. Clean shutdown with `signal.NotifyContext`. JSON helpers are consistent. You’ve removed adapter leakage from handlers by using `ports.IdentityFrom(ctx)`. Good step toward hexagonal.

# API & Architecture

**What’s good**

* `main` is a pure composition root.
* `registerHandlers` centralizes routes and fails fast.
* Adapter-agnostic identity access in handlers.

**Gaps / improvements**

1. **Config split.** `ports.MTLSConfig` still mixes HTTP tuning and auth policy. Split for reuse (HTTP vs mTLS vs SPIFFE). Keep a tiny “app config” that composes them.

```go
type HTTPServerConfig struct { Address string; ReadHeaderTimeout, ReadTimeout, WriteTimeout, IdleTimeout time.Duration; MaxHeaderBytes int }
type MTLSAuthConfig   struct { WorkloadSocket string; AllowedPeerIDs []string; AllowedTrustDomains []string }
type AppConfig struct { HTTP HTTPServerConfig; Auth MTLSAuthConfig }
```

2. **Policy shape.** Support multiple IDs and domains now, not just one of each. Your log line already implies it.

```go
// ENV: ALLOWED_CLIENT_IDS=spiffe://td/app-a,spiffe://td/app-b
// ENV: ALLOWED_TRUST_DOMAINS=example.org,internal.acme
```

3. **Health on a separate listener.** Keep `/health` unauthenticated, but bind it to `127.0.0.1:<port>` (plain HTTP). Avoid exposing it on the mTLS surface.

# Correctness, Reliability, Security

1. **Graceful shutdown path is good**, but be explicit on the “normal” error:

```go
go func() {
    if err := server.Start(ctx); err != nil && !errors.Is(err, http.ErrServerClosed) {
        log.Printf("server error: %v", err)
    }
}()
```

(You already do this—keep it.)

2. **Method safety.** Handlers should reject unexpected methods.

```go
func requireMethods(methods ...string) func(http.Handler) http.Handler {
    allowed := map[string]struct{}{}; for _, m := range methods { allowed[m]=struct{}{} }
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            if _, ok := allowed[r.Method]; !ok { writeJSONError(w, http.StatusMethodNotAllowed, "method not allowed"); return }
            next.ServeHTTP(w, r)
        })
    }
}
```

Apply to `/api/*`.

3. **Identity precondition.** Treat missing identity as **401** not **500**. It’s auth, not server failure.

```go
if !ok { writeJSONError(w, http.StatusUnauthorized, "missing identity"); return }
```

4. **Time-outs and header limits.** Add `MaxHeaderBytes` to cap memory burn on headers. You already set read/write/idle.

```go
cfg.HTTP.MaxHeaderBytes = 1 << 20 // 1 MiB (adjust to your needs)
```

5. **JSON encoding.** Avoid HTML escaping for clarity (IDs won’t need it) and set `Charset`.

```go
func writeJSON(w http.ResponseWriter, status int, v any) {
    w.Header().Set("Content-Type", "application/json; charset=utf-8")
    w.WriteHeader(status)
    enc := json.NewEncoder(w)
    enc.SetEscapeHTML(false)
    if err := enc.Encode(v); err != nil { log.Printf("json encode: %v", err) }
}
```

6. **Logging.** Prefer structured logs with request context and identity. Consider `log/slog`.

```go
logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
logger.Info("request", "method", r.Method, "path", r.URL.Path, "id", id.SPIFFEID)
```

7. **Config validation.** Validate mutually exclusive/required knobs (e.g., no auth configured).

```go
func validate(cfg ports.MTLSConfig) error {
    if cfg.WorkloadAPI.SocketPath == "" { return errors.New("workload socket required") }
    if cfg.SPIFFE.AllowedPeerID == "" && cfg.SPIFFE.AllowedTrustDomain == "" {
        return errors.New("configure ALLOWED_CLIENT_ID or ALLOWED_TRUST_DOMAIN")
    }
    return nil
}
```

Call it right after `loadConfig()`; fail fast with a clear message.

8. **Auth policy semantics.** If both peer and domain are set, document precedence (peer wins). Better: allow **both** and accept if either matches.

# Developer Experience & Testing

1. **Dev fake identity.** Provide a dev build-tag adapter that injects a fixed `ports.Identity` (no SPIRE needed). Your handlers remain unchanged and tests are trivial.

2. **httptest coverage.** Table-driven tests for:

   * 401 when identity missing.
   * 200 and JSON shape on `/api/hello` and `/api/identity`.
   * Shutdown completes within timeout.

3. **Contract tests for policy.** Given various env permutations, assert allow/deny decisions (IDs and trust domains, including prefixes).

4. **Observability.** Add a tiny middleware for latency and in-flight metrics (Prometheus or expvar). It pays off quickly.

# Small polish (quick wins)

* `getAllowedPeer`: when neither is set, your string says “any from trust domain” but policy defaults to a concrete peer. Make the message match the actual policy.
* Document all env vars in a `README` block and echo only non-sensitive values at startup. Avoid logging full allow-lists in prod unless at debug level.
* Add `ALLOWED_CLIENT_IDS` and `ALLOWED_TRUST_DOMAINS` now; keep current single-value vars for backward compatibility.

```go
func splitCSV(s string) []string {
    if s == "" { return nil }
    parts := strings.Split(s, ",")
    out := make([]string, 0, len(parts))
    for _, p := range parts { if v := strings.TrimSpace(p); v != "" { out = append(out, v) } }
    return out
}
```

# Minimal deltas (drop-in)

**Identity error codes**

```go
// in all handlers
id, ok := ports.IdentityFrom(r.Context())
if !ok { writeJSONError(w, http.StatusUnauthorized, "missing identity"); return }
```

**JSON writer**

```go
func writeJSON(w http.ResponseWriter, status int, v interface{}) {
    w.Header().Set("Content-Type", "application/json; charset=utf-8")
    w.WriteHeader(status)
    enc := json.NewEncoder(w)
    enc.SetEscapeHTML(false)
    if err := enc.Encode(v); err != nil { log.Printf("json encode: %v", err) }
}
```

**CSV support + config**

```go
authIDs := splitCSV(os.Getenv("ALLOWED_CLIENT_IDS"))
domains := splitCSV(os.Getenv("ALLOWED_TRUST_DOMAINS"))
// populate cfg.SPIFFE.{AllowedPeerIDs, AllowedTrustDomains}
```

**Health split (optional but recommended)**

* Keep `:8443` for mTLS routes.
* Start a second plain HTTP server on `127.0.0.1:8080` for `/health` only.

---

* You’ve fixed the biggest architectural smell (adapter leakage). Good.
* Next: split config, expand auth policy (lists), return 401 for missing identity, and move health to a local listener.
* Add structured logs, small metrics, and dev fake-identity for fast tests.
