Good structure and readable targets. Clear separation of prod/dev builds and CI bundles. A few correctness and portability issues exist. Several small changes will make it more robust and cross-platform.

# Correctness issues (fix first)

1. **Missing tools used by targets but not in `REQUIRED_TOOLS`**

* You call `bc`, `sed`, `awk`, `staticcheck`, `gocyclo`, `goimports`, `golangci-lint`, and `jq` across targets; only a subset are installed/checked.
* Result: CI may pass `check-prereqs` then fail later.

**Fix:**

* Either add them to `REQUIRED_TOOLS`, or check per-target.
* Add `staticcheck` to `refactor-install-tools` (it’s used but not installed there).

2. **`echo "\n..."` sequences won’t add newlines on many shells**

* `echo` typically prints the literal `\n`. Several targets (`refactor-baseline`, `refactor-compare`, `refactor-check`) rely on this.

**Fix:** use `printf` instead of `echo "\n..."`.

3. **`minikube-status` calls the “down” script**

* `minikube-status` invokes `infra/dev/minikube/scripts/cluster-down.sh status`. That looks like a mistake: “status” should live in an “up” or a neutral script.

**Fix:** point to the correct script (or provide a dedicated `cluster-status.sh`).

4. **`test-prod-build` symbol grep may false-positive**

* `go tool nm` substring grep on `selector|identitymapper` can catch unrelated symbols.
* False positives break CI.

**Fix:** grep for a stricter pattern (package path or symbol prefix), or rely on build tags verification via `go list -deps -tags=dev` diffing.

5. **`test-integration` depends on external state but has no `make` dependencies**

* The comment says it requires `minikube-up` and `register-test-workload`, but target doesn’t depend on them.

**Fix:**

```make
test-integration: minikube-up register-test-workload
	@echo "Running integration tests against SPIRE in Kubernetes..."
	@bash scripts/run-integration-tests.sh
```

6. **Some targets missing in `.PHONY`**

* `compare-sizes`, `test-inmem`, `test-inmem-html` aren’t listed. They should be phony.

**Fix:** add them to `.PHONY`.

# Portability & DX

1. **Shell strictness per recipe**

* Multi-line recipes run each line in a new shell (unless you depend on `\` joining). You use loops already; they’re ok, but failures can be masked.

**Improvement:** make Make more defensive.

```make
SHELL := /bin/bash
.SHELLFLAGS := -eu -o pipefail -c
.ONESHELL:
```

(Or keep `.ONESHELL` off and add `set -euo pipefail` to selected complex recipes.)

2. **Cross-platform `stat`**

* You already fall back between GNU/BSD forms. Good. Keep it.

3. **Global package lists**

* Repeating `./...` is fine, but for consistency and speed, define once:

```make
PKGS := $(shell go list ./...)
```

Then use `$(PKGS)` in tests.

4. **Race + coverage**

* When you care about coverage in CI, prefer `-race` + `-covermode=atomic` for correctness.

5. **Build scope**

* `go build -o $(BINARY_PROD) ./cmd` builds the `cmd` package only. If `cmd` contains multiple subcommands, consider `./cmd/...`. If it’s a single main, current form is ok.

# Focused improvements (copy-paste friendly)

## A) Expand `REQUIRED_TOOLS` and per-target checks

Keep global prereqs small, and validate extras where needed to avoid blocking local dev flows that don’t need Minikube/Helm.

```make
REQUIRED_TOOLS := go

# Optional tool groups
TOOLS_K8S := helm kubectl minikube
TOOLS_LINT := staticcheck golangci-lint gocyclo goimports
TOOLS_MISC := jq bc sed awk

check-prereqs:
	@echo "Checking prerequisites..."
	@for tool in $(REQUIRED_TOOLS); do \
		command -v $$tool >/dev/null 2>&1 || { echo "✗ $$tool not found"; exit 1; }; \
		echo "✓ $$tool"; \
	done
	@echo "✓ Core prerequisites satisfied"

check-prereqs-k8s:
	@for tool in $(TOOLS_K8S); do \
		command -v $$tool >/dev/null 2>&1 || { echo "✗ $$tool not found"; exit 1; }; \
		echo "✓ $$tool"; \
	done

check-prereqs-lint:
	@for tool in $(TOOLS_LINT); do \
		command -v $$tool >/dev/null 2>&1 || { echo "✗ $$tool not found"; exit 1; }; \
		echo "✓ $$tool"; \
	done

check-prereqs-misc:
	@for tool in $(TOOLS_MISC); do \
		command -v $$tool >/dev/null 2>&1 || { echo "✗ $$tool not found"; exit 1; }; \
		echo "✓ $$tool"; \
	done
```

Use these where relevant:

```make
helm-lint: check-prereqs-k8s
helm-template: check-prereqs-k8s
ci-test: check-prereqs check-prereqs-k8s check-prereqs-lint check-prereqs-misc test-coverage helm-lint helm-template test-prod-build
```

## B) Install tools (include staticcheck)

```make
refactor-install-tools:
	@echo "Installing refactoring analysis tools..."
	@go install honnef.co/go/tools/cmd/staticcheck@latest
	@go install github.com/fzipp/gocyclo/cmd/gocyclo@latest
	@go install github.com/uudashr/gocognit/cmd/gocognit@latest
	@go install golang.org/x/tools/cmd/goimports@latest
	@go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
	@echo "✓ Tools installed successfully"
```

## C) Use `printf` for newlines

Example fix for `refactor-baseline`:

```make
refactor-baseline:
	@echo "Generating refactoring baseline..."
	@mkdir -p docs/refactoring
	@date -Iseconds > docs/refactoring/baseline.txt
	@printf "\n=== File Sizes (Top 20) ===\n" >> docs/refactoring/baseline.txt
	@find . -name "*.go" -not -path "./vendor/*" -not -path "./.git/*" \
	| xargs wc -l | sort -rn | head -20 >> docs/refactoring/baseline.txt
	@printf "\n=== Cyclomatic Complexity (>15) ===\n" >> docs/refactoring/baseline.txt
	@gocyclo -over 15 . >> docs/refactoring/baseline.txt 2>&1 || echo "  (gocyclo not installed - run 'make refactor-install-tools')"
	@printf "\n=== Test Coverage ===\n" >> docs/refactoring/baseline.txt
	@go test ./... -coverprofile=docs/refactoring/coverage_before.out >/dev/null 2>&1 || true
	@go tool cover -func=docs/refactoring/coverage_before.out | tail -1 >> docs/refactoring/baseline.txt
	@printf "\n=== Test Execution Time ===\n" >> docs/refactoring/baseline.txt
	@{ time go test ./... >/dev/null 2>&1; } 2>> docs/refactoring/baseline.txt || true
	@echo "Baseline saved to docs/refactoring/baseline.txt"
	@cat docs/refactoring/baseline.txt
```

Apply similar `printf` changes in `refactor-compare` and `refactor-check`.

## D) Tighten `compare-sizes` without `bc`

Avoid extra dependency:

```make
compare-sizes:
	@echo "Building and comparing binary sizes..."
	@mkdir -p bin
	@go build -trimpath $(LDFLAGS) -o bin/agent-prod ./cmd
	@go build -tags=$(BUILD_TAGS_DEV) -o bin/agent-dev ./cmd
	@ls -lh bin/agent-prod bin/agent-dev
	@PROD_SIZE=$$(stat -c%s bin/agent-prod 2>/dev/null || stat -f%z bin/agent-prod); \
	DEV_SIZE=$$(stat -c%s bin/agent-dev 2>/dev/null || stat -f%z bin/agent-dev); \
	DIFF=$$((DEV_SIZE - PROD_SIZE)); \
	PCT=$$(awk -v d=$$DIFF -v all=$$DEV_SIZE 'BEGIN{ if(all==0){print 0}else{printf "%.2f", (d*100)/all}}'); \
	printf "Production binary: %s bytes\nDevelopment binary: %s bytes\nSize difference: %s bytes (%s%% of dev)\n" $$PROD_SIZE $$DEV_SIZE $$DIFF $$PCT
```

## E) Safer prod/dev test checks

* Instead of grepping `nm`, ensure dev-only packages aren’t in the prod dependency graph:

```make
test-prod-build:
	@echo "Testing production build..."
	@go build -o /tmp/test-prod ./cmd
	@go build -tags=dev -o /tmp/test-dev ./cmd
	@echo "→ Verifying dev-only pkgs not in prod deps..."
	@! go list -deps ./cmd | grep -q '/internal/.*/inmemory' || { echo "✗ Dev-only package present in prod deps"; exit 1; }
	@echo "→ Verifying dev tests appear only with -tags=dev..."
	@! go test -list . ./internal/domain | grep -qE 'TestSelector|TestIdentityMapper' || { echo "✗ Dev tests visible without -tags"; exit 1; }
	@go test -tags=dev -list . ./internal/domain | grep -qE 'TestSelector|TestIdentityMapper' || { echo "✗ Dev tests not visible with -tags=dev"; exit 1; }
	@rm -f /tmp/test-prod /tmp/test-dev
	@echo "✓ Production build check passed"
```

## F) Add missing `.PHONY`

```make
.PHONY: compare-sizes test-inmem test-inmem-html
```

## G) Optional: shared vars for tests

```make
PKGS := $(shell go list ./...)
GO_TEST_FLAGS ?=
GO_TEST_FLAGS_RACE ?= -race -covermode=atomic

test-dev:
	@go test -tags=$(BUILD_TAGS_DEV) $(GO_TEST_FLAGS) $(PKGS)

test-race:
	@go test $(GO_TEST_FLAGS_RACE) $(PKGS)

test-coverage:
	@go test -covermode=atomic -coverprofile=coverage.out $(PKGS)
	@go tool cover -func=coverage.out
```

* Add/check all tools you use, or scope checks per-target.
* Replace `echo "\n"` with `printf` to ensure newlines.
* Fix `minikube-status` script path.
* Make `test-integration` depend on its prerequisites.
* Prefer dependency-graph checks over nm/grep for dev-only code.
* Add missing `.PHONY` targets and consider stricter shell flags for reliability.
