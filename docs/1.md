# 1) Surface quality (good)

* Clear startup/shutdown path; graceful stop is handled.
* Logging is readable; errors are checked.
* Handlers are small and cohesive.
* Config uses env with sane defaults.

solid baseline; safe to iterate.

# 2) API design review

### What the API exposes (implicit contract)

* `identityserver.New(ctx, cfg)` returns a server with:

  * `Handle(pattern, http.Handler)`
  * `Start(ctx)`, `Shutdown(ctx)`, `Close()`

This is a good “minimal HTTP server” façade. Two design tensions remain:

1. **Coupling to a concrete adapter**
   Handlers call `identityserver.GetIdentity(r)`. That leaks an **inbound adapter** concern into application code. It defeats the port/adapter boundary.

2. **Mixed configuration concerns**
   `ports.MTLSConfig` holds both HTTP tuning and SPIFFE/mTLS auth. That couples transport tuning to identity policy. Harder to reuse across different inbound adapters (e.g., gRPC).

**Fix (direction):**

* Replace `identityserver.GetIdentity` calls with a **port-neutral identity accessor** (via request context).
* Split config into `HTTPServerConfig` and `AuthConfig` (or `MTLSAuthConfig`). Keep them composed at the composition root.

# 3) Hexagonal fit

* **Good:** `main` acts as composition root; `identityserver` looks like an inbound adapter; `ports` provides the config type.
* **Not good:** Handlers depend on an **adapter utility** to fetch identity, rather than a **driving port** concept (e.g., “RequestIdentity” abstraction).
  In hexagonal terms: driving adapters should translate protocol → **domain-level request**; the app should see identities in a domain shape, not via adapter types.

move identity extraction to middleware in the adapter; handlers see a domain-friendly value via context.

# 4) Targeted improvements

## A) Decouple identity from the adapter

**Problem:** `identityserver.GetIdentity(r)` ties handlers to the inbound adapter.

**Improve:** middleware in the **identityserver** adapter stores identity in `context.Context`. Handlers read it through a small, **port-owned** helper.

```go
// ports/identity.go (driving-port-facing shape)
package ports

import "context"

type Identity struct {
    SPIFFEID     string
    TrustDomain  string
    Path         string
}

type identityKey struct{}

func WithIdentity(ctx context.Context, id Identity) context.Context {
    return context.WithValue(ctx, identityKey{}, id)
}

func IdentityFrom(ctx context.Context) (Identity, bool) {
    id, ok := ctx.Value(identityKey{}).(Identity)
    return id, ok
}
```

Adapter middleware (inside `identityserver`) maps SPIFFE → `ports.Identity` and calls `ports.WithIdentity(r.Context(), id)`.
Handlers now depend on **ports**, not on `identityserver`:

```go
func handleHello(w http.ResponseWriter, r *http.Request) {
    id, ok := ports.IdentityFrom(r.Context())
    if !ok { http.Error(w, "No identity", http.StatusUnauthorized); return }
    w.Header().Set("Content-Type", "text/plain")
    fmt.Fprintf(w, "Hello!\nAuthenticated client: %s\n", id.SPIFFEID)
}
```

**Benefit:** handlers are adapter-agnostic; you can swap HTTP, gRPC, or CLI adapters without touching handlers.

## B) Separate config concerns

**Problem:** `ports.MTLSConfig` includes HTTP timeouts and SPIFFE policy.

**Improve:** two structs the app composes:

```go
type HTTPServerConfig struct {
    Address           string
    ReadHeaderTimeout time.Duration
    ReadTimeout       time.Duration
    WriteTimeout      time.Duration
    IdleTimeout       time.Duration
    MaxHeaderBytes    int
}

type MTLSAuthConfig struct {
    WorkloadSocket   string   // SPIFFE_ENDPOINT_SOCKET by default
    AllowedPeerIDs   []string // support list/prefixes
    // Optional: AllowedTrustDomains []string
}
```

**Benefit:** reuse auth across different inbound protocols; tune HTTP independently.

## C) Strengthen graceful shutdown

* Use `signal.NotifyContext` to simplify cancellation wiring.
* Treat `http.ErrServerClosed` as a normal case from `Start`.

```go
ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
defer stop()

go func() {
    if err := server.Start(ctx); err != nil && !errors.Is(err, http.ErrServerClosed) {
        log.Printf("Server error: %v", err)
    }
}()

<-ctx.Done()
shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
_ = server.Shutdown(shutdownCtx)
```

## D) Consistent response shapes + content types

* `/api/*` should return **JSON** consistently.
* Return problem details (status code, message) in a stable schema.
* Keep `Content-Type` explicit.

```go
func writeJSON(w http.ResponseWriter, status int, v any) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    _ = json.NewEncoder(w).Encode(v)
}
```

## E) Security/policy knobs

* Support **multiple** allowed SPIFFE IDs and/or **trust-domain** allow-lists.
* Consider **prefix match** on SPIFFE path for service groups.
* Optional: health endpoint on a **separate, unauthenticated** listener (localhost) to avoid exposing it on the mTLS surface.

```go
// Example: split listeners
// :8443 (mTLS, app routes) and 127.0.0.1:8080 (/health plain HTTP)
```

## F) Observability

* Move to `slog` (or zap) for structured logs. Include request id, method, path, and identity.
* Add basic metrics (in-flight requests, latency buckets). Even a tiny `expvar` or Prometheus handler helps.

## G) Testing ergonomics

* Provide an **in-memory identity provider** (dev build tag) that injects a fake `ports.Identity` via middleware.
* Use `httptest.Server` for handler tests, verify auth propagation and JSON shape.
* Add a quick **contract test** for `Start/Shutdown` timing.

## H) Small polish

* Add `ReadTimeout` (you already set `ReadHeaderTimeout` and `WriteTimeout`).
* Consider `MaxHeaderBytes` to prevent header abuse.
* Normalize env names: SPIFFE uses `SPIFFE_ENDPOINT_SOCKET`; accept it and fall back to your current var for compatibility.
* Replace repeated handler registration error handling with a tiny helper, or let `Handle` panic on duplicates in dev.

---

## Revised wiring sketch (composition root)

```go
func main() {
    ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
    defer stop()

    httpCfg := ports.HTTPServerConfig{
        Address:           getEnv("SERVER_ADDRESS", ":8443"),
        ReadHeaderTimeout: 10 * time.Second,
        ReadTimeout:       15 * time.Second,
        WriteTimeout:      30 * time.Second,
        IdleTimeout:       120 * time.Second,
        MaxHeaderBytes:    1 << 20, // 1MB
    }
    authCfg := ports.MTLSAuthConfig{
        WorkloadSocket: getFirstNonEmpty(
            os.Getenv("SPIFFE_ENDPOINT_SOCKET"),
            getEnv("SPIRE_AGENT_SOCKET", "unix:///tmp/spire-agent/public/api.sock"),
        ),
        AllowedPeerIDs: splitCSV(getEnv("ALLOWED_CLIENT_IDS", "spiffe://example.org/client")),
    }

    srv, err := identityserver.New(ctx, httpCfg, authCfg) // accept split configs
    if err != nil { log.Fatalf("create server: %v", err) }
    defer srv.Close()

    // Adapter provides middleware that injects ports.Identity into context.
    mux := http.NewServeMux()
    mux.Handle("/", withIdentity(handleRoot))
    mux.Handle("/api/hello", withIdentity(handleHello))
    mux.Handle("/api/identity", withIdentity(handleIdentity))
    mux.Handle("/health", http.HandlerFunc(handleHealth))
    if err := srv.Mount(mux); err != nil { log.Fatalf("mount: %v", err) }

    go func() {
        if err := srv.Start(ctx); err != nil && !errors.Is(err, http.ErrServerClosed) {
            log.Printf("server error: %v", err)
        }
    }()

    <-ctx.Done()
    _ = srv.Shutdown(context.Background())
}
```

---

* Keep handlers **adapter-agnostic**: move identity extraction to adapter middleware; expose a port-level identity shape via context.
* **Split config**: `HTTPServerConfig` vs `MTLSAuthConfig`. Compose at the edge.
* Tighten **shutdown**, **JSON consistency**, and **observability**.
* Expose **policy** (multiple IDs / trust-domains) as first-class config.
* Provide **fake identity** for tests via dev build tags to keep tests fast and deterministic.
