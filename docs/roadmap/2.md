We’ll design this so you don’t fork the codebase, and you don’t weaken security in dev.

We’ll walk in layers:

1. Ground truth of how SPIRE works in both cases
2. What this means for your library (the port)
3. How to run dev/test with unix attestor
4. How to run prod with k8s attestor
5. Build/runtime selection strategy

The idea: the library should not care whether the workload was attested via `unix` or `k8s`. That choice lives below your abstraction.

---

## 1. Ground truth

Attestation happens between:

* your process
* the SPIRE Agent next to you

The agent decides *how* you prove who you are:

* on bare metal / VM / laptop → `unix` attestor

  * uses Linux kernel data (UID, GID, PID, executable path)
* in Kubernetes → `k8s` attestor

  * uses pod metadata (namespace, service account, labels)

After attestation succeeds, you get the same output shape:

* an SVID (X.509 SVID or JWT SVID)
* a SPIFFE ID like `spiffe://example.org/my-service`

Your Go code that calls `go-spiffe` just asks the Workload API for “my identity”. It does not negotiate how it was proven.

So: unix vs k8s is an environment concern, not an application concern.

You should reflect that in design.

---

## 2. Your library’s contract (the port)

Expose one clean port to the rest of the app. Example:

```go
// ports/identity.go
package ports

import "context"

type WorkloadIdentity struct {
    SPIFFEID string // stable input to authz, logging, audit
    // You can add extras (Namespace, UID, etc.) if you need them for policy.
}

type IdentityService interface {
    // Return caller identity for the current process / current connection.
    Current(ctx context.Context) (WorkloadIdentity, error)
}
```

Your handlers / business logic / middleware only depend on `IdentityService`.

They do not know:

* am I on a laptop?
* am I in k8s?
* did we use unix attestor or k8s attestor?

That is critical. This is how you avoid branching the whole stack.

---

## 3. Development & test environment (unix attestor)

### Agent side

In dev:

* You run a SPIRE Server + SPIRE Agent on Ubuntu 24.
* The Agent is configured with the `unix` workload attestor.
* You create registration entries that bind a SPIFFE ID to selectors like:

  * `unix:uid:1000`
  * `unix:gid:1000`
  * `unix:exe:/home/bala/bin/my-service`

Result:
Your local process proves “I am UID 1000 running /home/bala/bin/my-service”, and the agent issues `spiffe://dev.local/my-service`.

### Library side

In your code, your IdentityService implementation talks to the Workload API socket, using `go-spiffe`:

```go
// internal/adapters/spiffeidentity/identity_service.go
package spiffeidentity

import (
    "context"
    "fmt"

    "github.com/spiffe/go-spiffe/v2/workloadapi"
    "github.com/spiffe/go-spiffe/v2/spiffeid"

    "your/module/internal/ports"
)

type IdentityServiceSPIFFE struct {
    client *workloadapi.Client
}

func NewIdentityServiceSPIFFE(ctx context.Context, socketPath string) (*IdentityServiceSPIFFE, error) {
    c, err := workloadapi.New(ctx,
        workloadapi.WithAddr(socketPath),
        workloadapi.WithClientOptions(), // rotation etc, defaults ok
    )
    if err != nil {
        return nil, err
    }
    return &IdentityServiceSPIFFE{client: c}, nil
}

func (s *IdentityServiceSPIFFE) Current(ctx context.Context) (ports.WorkloadIdentity, error) {
    svid, err := s.client.FetchX509SVID(ctx)
    if err != nil {
        return ports.WorkloadIdentity{}, fmt.Errorf("fetch SVID: %w", err)
    }

    id := svid.ID // spiffeid.ID
    return ports.WorkloadIdentity{
        SPIFFEID: id.String(),
    }, nil
}
```

Important:

* This code does not know “unix attestor”.
* It just asks the Workload API.

The only dev-specific detail is the socket path to the agent.
Example dev path:

```go
socketPath := "unix:///tmp/spire-agent.sock"
```

So in dev/test:

* You run SPIRE with unix attestor.
* You point `NewIdentityServiceSPIFFE` at that agent socket.
* Done.

No insecure fallback. No special “fake identity.” You are using real SPIFFE IDs issued by SPIRE.

---

## 4. Production environment (k8s attestor)

In Kubernetes:

* SPIRE Agent runs as a DaemonSet.
* The agent is configured with the `k8s` workload attestor.
* The agent exposes the Workload API to each pod (usually mounted as a Unix socket in the pod’s filesystem).
* Registration entries match pod selectors such as namespace, service account, etc.

Your production workload calls the same code:

```go
identitySvc := NewIdentityServiceSPIFFE(ctx, "unix:///spiffe-workload-api/spire-agent.sock")
id, _ := identitySvc.Current(ctx)
// id.SPIFFEID -> "spiffe://prod.example.com/payments-api"
```

From the library’s point of view, nothing changed except the socket path and trust domain.

So prod == dev at the library boundary.

---

## 5. Switch between dev and prod

There are 2 clean ways to select behavior.

### Option A. Runtime configuration only (preferred)

* You always build the same binary.
* You pass config:

  * agent socket path
  * expected trust domain
* You let SPIRE decide which attestor is appropriate.

Example config struct:

```go
type IdentityConfig struct {
    WorkloadAPISocket string // e.g. "unix:///tmp/spire-agent.sock"
    ExpectedTrustDomain string // e.g. "spiffe://dev.local" or "spiffe://prod.example.com"
}
```

Your wiring code:

```go
func WireIdentity(ctx context.Context, cfg IdentityConfig) (ports.IdentityService, error) {
    return spiffeidentity.NewIdentityServiceSPIFFE(ctx, cfg.WorkloadAPISocket)
}
```

In dev:

```bash
IDENTITY_SOCKET="unix:///tmp/spire-agent.sock"
IDENTITY_TRUSTDOMAIN="spiffe://dev.local"
./server
```

In prod (in pod env):

```bash
IDENTITY_SOCKET="unix:///spire-agent-socket/agent.sock"
IDENTITY_TRUSTDOMAIN="spiffe://prod.example.com"
./server
```

No build tags. Same codepath. Operational simplicity.

This is usually what you want if you truly plan to run SPIRE locally in dev using the unix attestor.

### Option B. Build tags (only if you cannot run SPIRE in dev)

You only need build tags if:

* you sometimes *don’t* run SPIRE in dev
* you want an “offline mode” that uses SO_PEERCRED directly instead of a real SPIRE agent

Then:

* `//go:build dev` adapter: read PID/UID/GID via SO_PEERCRED, synthesize a SPIFFE-like ID
* `//go:build !dev` adapter: real SPIRE / go-spiffe client as shown above

But:
If you are okay running a local SPIRE Server + Agent on Ubuntu and registering workloads with `unix` selectors, Option A is better. You don’t need a fake adapter at all. You are testing the real path end-to-end.

---

Your plan (“use unix attestor in development/test, use k8s attestor in production”) works naturally with SPIRE. You do not need two different versions of your library.

You do this:

1. Define an interface (`IdentityService`) that returns a normalized identity value object (`WorkloadIdentity`).
2. Implement that interface once, using `go-spiffe` to talk to the Workload API.
3. In development:

   * Run SPIRE Agent configured with the `unix` workload attestor.
   * Expose its socket locally.
   * Register your dev process (UID/exe path) so it gets an SVID.
4. In production:

   * Run SPIRE Agent in k8s with the `k8s` workload attestor.
   * Mount the agent socket into the pod.
   * Register workloads using k8s selectors (namespace, service account).
5. At runtime, pass the correct socket path and trust domain into the same adapter.

takeaway:

* The library should never branch on “unix vs k8s”.
* The SPIRE Agent handles attestation style.
* Your library just consumes SPIFFE identity through one stable port.
