We will make four improvements:

1. Seal the registry inside the factory and return only the interface.
2. Hide mutating methods behind the factory so nothing else can seed.
3. Make the dev CA obviously unsafe and impossible to ship.
4. Align bootstrap timeout with the doc.

I’ll give you the diff-style steps in order. After you apply these, your dev mode will be safer, harder to misuse, and aligned with what your docs claim.

---

## Step 1. Update the registry to support sealing and expose no mutators

### 1.1 Current (what you described)

```go
type InMemoryRegistry struct {
    mappers map[string]*domain.IdentityMapper
    sealed  bool
}

// Seed(...)
func (r *InMemoryRegistry) Seed(ctx context.Context, mapper *domain.IdentityMapper) error { ... }

// Seal()
func (r *InMemoryRegistry) Seal() { ... }

// FindBySelectors(...)
func (r *InMemoryRegistry) FindBySelectors(ctx context.Context, selectors *domain.SelectorSet) (*domain.IdentityMapper, error) { ... }

// ListAll(...)
func (r *InMemoryRegistry) ListAll(ctx context.Context) ([]*domain.IdentityMapper, error) { ... }
```

### 1.2 Goal

* After factory returns the registry:

  * there is no way to call `Seed` or `Seal` anymore.
* Callers (bootstrap, services, agent) should only see the read-only port:
  `ports.IdentityMapperRegistry`.

### 1.3 Actions

1. Keep `InMemoryRegistry` as is in `internal/adapters/outbound/inmemory/registry.go` (dev build).
2. Do **not** export `Seed` or `Seal` outside the inmemory package.

   * Rename them to lowercase so they are package-private.

For example:

```go
// internal/adapters/outbound/inmemory/registry.go
//go:build dev

package inmemory

type InMemoryRegistry struct {
    mappers map[string]*domain.IdentityMapper
    sealed  bool
}

// seed adds an identity mapper during bootstrap/factory only.
func (r *InMemoryRegistry) seed(ctx context.Context, mapper *domain.IdentityMapper) error {
    if r.sealed {
        return domain.ErrRegistrySealed
    }
    // ... existing logic ...
    return nil
}

// seal prevents further mutation.
func (r *InMemoryRegistry) seal() {
    r.sealed = true
}

// FindBySelectors and ListAll stay exported because they are part of the port.
func (r *InMemoryRegistry) FindBySelectors(...) ...
func (r *InMemoryRegistry) ListAll(...) ...
```

Now only code in the same package (`inmemory`) can seed or seal. Everyone else just sees read-only methods.

This enforces “immutable after bootstrap” physically.

---

## Step 2. Change the factory to (a) seed, (b) seal, (c) return interface

### 2.1 Current (what you showed)

```go
func (f *InMemoryAdapterFactory) CreateRegistry(
    ctx context.Context,
    workloads []dto.WorkloadEntry,
    parser ports.IdentityCredentialParser,
) (*inmemory.InMemoryRegistry, error) {

    registry := inmemory.NewInMemoryRegistry()

    for _, workload := range workloads {
        // build mapper ...
        if err := registry.Seed(ctx, mapper); err != nil {
            return nil, err
        }
    }

    return registry, nil // not sealed yet
}
```

### 2.2 Goal

* After `CreateRegistry` returns:

  * registry is seeded
  * registry is sealed
  * caller only sees `ports.IdentityMapperRegistry`, which does not allow mutation

### 2.3 Actions

Change the function like this:

```go
// internal/adapters/outbound/compose/inmemory.go
//go:build dev

package compose

import (
    "context"

    "your/module/internal/adapters/outbound/inmemory"
    "your/module/internal/domain"
    "your/module/internal/dto"
    "your/module/internal/ports"
)

func (f *InMemoryAdapterFactory) CreateRegistry(
    ctx context.Context,
    workloads []dto.WorkloadEntry,
    parser ports.IdentityCredentialParser,
) (ports.IdentityMapperRegistry, error) { // <-- return interface
    reg := inmemory.NewInMemoryRegistry()

    for _, workload := range workloads {
        identityCredential, err := parser.ParseFromString(ctx, workload.SpiffeID)
        if err != nil {
            return nil, err
        }

        selector, err := domain.ParseSelectorFromString(workload.Selector)
        if err != nil {
            return nil, err
        }

        selectorSet := domain.NewSelectorSet()
        selectorSet.Add(selector)

        mapper, err := domain.NewIdentityMapper(identityCredential, selectorSet)
        if err != nil {
            return nil, err
        }

        // use package-private mutator
        if err := reg.seed(ctx, mapper); err != nil {
            return nil, err
        }
    }

    // IMPORTANT: seal before returning
    reg.seal()

    // Now we upcast to the port interface on return.
    // Callers cannot call seed() or seal() because those are unexported.
    return reg, nil
}
```

Also update the factory interface/struct accordingly wherever `CreateRegistry` is called.

This gives you:

* sealed registry instance
* no external seeding
* no risk of runtime mutation
* doc and code agree

---

## Step 3. Make “dev CA is unsafe” explicit in code and impossible to ship

You said: deterministic CA (fixed NotBefore, seeded RNG, etc.). That’s fine for replayable tests but dangerous if someone reuses it.

We will:

1. Mark the in-memory CA generator file with `//go:build dev`.
2. Add a runtime assertion that panics if it’s somehow built without `dev`. This is defensive, but useful.

### 3.1 In `internal/adapters/outbound/inmemory/server.go` (or wherever you generate the CA):

```go
//go:build dev

package inmemory

import (
    "crypto/rand"
    "crypto/rsa"
    "crypto/x509"
    "errors"
    "fmt"
    // ...
)

// NewInMemoryServer creates a dev-only CA and identity issuer.
// This CA is intentionally weak / deterministic.
// DO NOT USE IN PRODUCTION BUILDS.
func NewInMemoryServer(/* ... */) (*InMemoryServer, error) {
    if !devBuildGuard() {
        // This should never happen. Defense-in-depth.
        return nil, errors.New("inmemory server used outside dev build")
    }

    // 1. generate or load deterministic CA key/cert
    //    (your existing logic: fixed NotBefore, seeded RNG, etc.)

    // 2. construct server struct

    return &InMemoryServer{/*...*/}, nil
}

// devBuildGuard returns true in dev builds.
// In prod builds this file doesn't compile at all due to build tag,
// so this is mostly documentary.
func devBuildGuard() bool { return true }
```

### 3.2 Add an explicit comment block:

At top of file:

```go
// SECURITY NOTE:
// The CA in this file is for local development only. Keys and certs are
// intentionally predictable for reproducibility and testing. Never reuse
// this CA, these keys, or these certs in any production system.
```

Now:

* Anyone reading the code sees loud warnings.
* The file literally cannot build without `//go:build dev`.
* Your internal docs (“this is intentionally predictable”) are now enforced in code.

This satisfies your stated design rationale and prevents accidental leakage.

---

## Step 4. Align bootstrap timeout with documentation

You said bootstrap applies a default 10-second timeout. The snippet didn’t show it. We’ll add it.

In `internal/app/bootstrap_dev.go`:

```go
//go:build dev

package app

import (
    "context"
    "fmt"
    "time"

    "your/module/internal/adapters/outbound/compose"
    "your/module/internal/ports"
)

func Bootstrap(
    ctx context.Context,
    configLoader ports.ConfigLoader,
    factory *compose.InMemoryAdapterFactory,
) (*Application, error) {
    // Step 0: ensure we have a timeout
    if _, hasDeadline := ctx.Deadline(); !hasDeadline {
        var cancel context.CancelFunc
        ctx, cancel = context.WithTimeout(ctx, 10*time.Second)
        defer cancel()
    }

    // Step 1: Load configuration (fixtures)
    cfg, err := configLoader.Load(ctx)
    if err != nil {
        return nil, fmt.Errorf("load config: %w", err)
    }

    // Step 2: Initialize parsers and providers
    tdParser := factory.CreateTrustDomainParser()
    idParser := factory.CreateIdentityCredentialParser()
    docProvider := factory.CreateIdentityDocumentProvider()

    // Step 3: Create server (dev CA)
    server, err := factory.CreateServer(ctx, cfg.TrustDomain, tdParser, docProvider)
    if err != nil {
        return nil, fmt.Errorf("create server: %w", err)
    }

    // Step 4: Create registry (seeded+sealed in factory)
    registry, err := factory.CreateRegistry(ctx, cfg.Workloads, idParser)
    if err != nil {
        return nil, fmt.Errorf("create registry: %w", err)
    }

    // Step 5: Create attestor
    attestor := factory.CreateAttestor(cfg.Workloads)

    // Step 6: Create agent
    agent, err := factory.CreateAgent(ctx,
        cfg.AgentSpiffeID,
        server,
        registry,
        attestor,
        idParser,
        docProvider,
    )
    if err != nil {
        return nil, fmt.Errorf("create agent: %w", err)
    }

    // Step 7: Initialize services
    identitySvc, err := NewIdentityClientService(agent)
    if err != nil {
        return nil, fmt.Errorf("create identity client service: %w", err)
    }
    service := NewIdentityService(agent, registry)

    // Step 8: Wire final application
    return New(cfg, service, identitySvc, agent, registry)
}
```

Now:

* The contract in the doc (“Bootstrap guards against infinite waits with 10s timeout”) is true in code.
* Any dev call that hangs (for example, accidental DNS or file IO stall) will fail fast.

---

## Step 5. Final checklist / enforcement

After applying Steps 1–4, verify these points hold:

1. **Immutability guarantee**

   * `InMemoryRegistry.seed` and `InMemoryRegistry.seal` are package-private.
   * `CreateRegistry()` seeds, seals, and returns the interface `ports.IdentityMapperRegistry`.
   * No other code can mutate the registry after factory returns.

2. **No control-plane mutation at runtime**

   * Bootstrap never gets a mutable registry.
   * Runtime agent can only `FindBySelectors` and `ListAll`.

3. **Documentation matches code**

   * Docs now say “registry is sealed before it escapes factory.” True.
   * Docs say “bootstrap enforces 10s timeout.” True.
   * Docs say “CA is intentionally weak and dev-only.” True and enforced by build tags.

4. **Hexagonal boundary is cleaner**

   * Application layer depends on port interfaces (`ports.IdentityMapperRegistry`, `ports.IdentityServer`, etc.).
   * Only the dev factory touches concrete in-memory structs.

5. **Production safety**

   * The dev CA code and in-memory control plane code are all behind `//go:build dev`.
   * Production builds never compile them, so they cannot leak into prod.

---

## Summary of what to actually do in code

1. Rename `Seed()` → `seed()` and `Seal()` → `seal()` in `InMemoryRegistry`.
   Make them unexported. Keep read methods exported.

2. In the factory:

   * After seeding, call `reg.seal()`.
   * Return `ports.IdentityMapperRegistry` instead of `*InMemoryRegistry`.

3. Add loud `// SECURITY NOTE` and `//go:build dev` to the in-memory CA / server code.
   Optionally add a guard function like `devBuildGuard()`.

4. Add the 10-second timeout logic at the top of `Bootstrap()` and update any docs/examples to reflect that exact code.

After these steps, the design you wrote is not only conceptually correct, it’s enforceable by code boundaries and build constraints.
