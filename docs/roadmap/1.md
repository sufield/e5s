Good question. You already have the “real thing” (go-spiffe, SPIRE, mTLS, etc.) for production. You don’t want to rewrite logic for development. You want to run demos on a laptop without SPIRE, but still exercise your code paths and keep security properties.

We can do that by keeping your abstraction (ports) fixed, and swapping only the adapter behind it.

I’ll describe the pattern step by step.

We’ll use these terms:

* Domain / Core: code that your application calls (your library’s public API).
* Production adapter: talks to SPIRE / go-spiffe.
* Dev adapter: talks to local Unix socket + SO_PEERCRED.

You already have the first two. We will design the third to “look” identical to the second from the domain’s point of view.

---

## 1. Identify your stable port

In hexagonal terms you already have a port like this (naming may differ, adjust to yours):

```go
// ports/IdentityProvider.go (example)
type IdentityProvider interface {
    // WhoAmI returns the caller's workload identity as understood by
    // the trust domain (SPIFFE ID, selectors, etc.).
    WhoAmI(ctx context.Context) (Identity, error)

    // AuthorizePeer checks whether the peer (incoming request) is allowed
    // to do X.
    AuthorizePeer(ctx context.Context, action string) error
}
```

or you may have separated concerns:

* one port to “extract peer identity” from the transport (mTLS connection, etc.)
* one port to “map that identity to permissions”

Either way:

* This is the surface your app code calls.
* Your HTTP handlers / gRPC interceptors / CLI commands depend on this interface, not directly on go-spiffe.

This port is what must stay identical across prod and dev.

If you don’t have a clean port yet, create it now. This is the contract.

Key rule:

* Do NOT let `*workloadapi.X509SVID` or `spiffeid.ID` from go-spiffe leak past this port into the rest of the app. Wrap them in your own `Identity` struct (value object).

Example:

```go
// ports/identity.go
package ports

type WorkloadID struct {
    SPIFFEID string // "spiffe://example.org/workload-a"
    PID      int    // optional, for local dev attestation / audit
    UID      int    // optional
}

type IdentityService interface {
    CurrentWorkload(ctx context.Context) (WorkloadID, error)
}
```

Now everything above the port (handlers, business logic) only knows `IdentityService`.

---

## 2. Production adapter (you already have this)

In prod you probably have something like:

* Use `go-spiffe` Workload API client to fetch SVID.
* Use mTLS to authenticate peers.
* Extract peer SPIFFE ID from `tls.ConnectionState`.
* Return that as your `WorkloadID`.

That implementation satisfies `IdentityService`.

Call it:

```go
internal/adapters/spireprod/identity_service.go
// +build !dev
```

(or `//go:build !dev` in modern syntax)

This is already done in your system.

---

## 3. Development adapter (what you need)

Goal:

* No SPIRE server/agent.
* No forged headers.
* Still returns a `WorkloadID` to the rest of the app using the same port.

We will build an in-memory / local-IPC adapter that still proves identity using kernel attestation (SO_PEERCRED) and maps it deterministically to a SPIFFE-like ID so the rest of your stack behaves the same.

Call it:

```go
internal/adapters/inmemorydev/identity_service_dev.go
//go:build dev
```

Behavior of this dev adapter:

1. Read peer creds from the Unix domain socket using `SO_PEERCRED` (PID, UID, GID).
2. Convert those creds into a “synthetic SPIFFE ID” string in your trust domain, for example:
   `spiffe://dev.local/uid-1000/bin-client-demo`
3. Return that as `WorkloadID{SPIFFEID: "...", PID: ..., UID: ...}`.

Now:

* Your business logic still sees a SPIFFE-like ID.
* Your authorization layer can still do the same checks (“is caller allowed to call /admin?”).
* You did not water down security; you just changed how identity is established.

Sketch:

```go
// internal/adapters/inmemorydev/identity_service_dev.go
//go:build dev

package inmemorydev

import (
    "context"
    "fmt"
    "path/filepath"
    "os"

    "your/module/internal/workloadapi/localpeer" // helper that does SO_PEERCRED
    "your/module/internal/ports"
)

type IdentityServiceDev struct {
    // maybe preload an allowlist, etc.
}

func NewIdentityServiceDev() *IdentityServiceDev {
    return &IdentityServiceDev{}
}

func (s *IdentityServiceDev) CurrentWorkload(ctx context.Context) (ports.WorkloadID, error) {
    cred, err := localpeer.FromCtx(ctx) // this pulls PID/UID/GID captured at accept()
    if err != nil {
        return ports.WorkloadID{}, fmt.Errorf("no peer cred: %w", err)
    }

    exe, err := os.Readlink(fmt.Sprintf("/proc/%d/exe", cred.PID))
    if err != nil {
        exe = "unknown"
    }

    spiffeLike := fmt.Sprintf(
        "spiffe://dev.local/uid-%d/%s",
        cred.UID,
        filepath.Base(exe),
    )

    return ports.WorkloadID{
        SPIFFEID: spiffeLike,
        PID:      int(cred.PID),
        UID:      int(cred.UID),
    }, nil
}
```

Important point:

* `CurrentWorkload` still returns something that *looks like* a SPIFFE ID.
* Callers above don’t care if it came from SPIRE or from SO_PEERCRED.

That’s how you reuse the abstraction.

---

## 4. Capturing SO_PEERCRED and putting it in context

In prod, you probably already have middleware that:

* looks at the TLS connection
* extracts the peer SPIFFE ID
* stores it in `context.Context` so handlers can call `IdentityService.CurrentWorkload(ctx)`.

Do the same in dev, except:

* when you accept a Unix socket connection
* you call `GetsockoptUcred`
* you stash `{PID,UID,GID}` into the request context
* you pass that context into the handler.

Example minimal middleware for dev:

```go
// internal/workloadapi/localpeer/cred.go
package localpeer

type Cred struct {
    PID int32
    UID uint32
    GID uint32
}

type ctxKey struct{}

func WithCred(ctx context.Context, c Cred) context.Context {
    return context.WithValue(ctx, ctxKey{}, c)
}

func FromCtx(ctx context.Context) (Cred, error) {
    v := ctx.Value(ctxKey{})
    c, ok := v.(Cred)
    if !ok {
        return Cred{}, fmt.Errorf("no local peer cred in context")
    }
    return c, nil
}
```

Your dev “server loop” (Unix socket acceptor) would:

* extract `Cred` via `SO_PEERCRED`
* wrap the handler with `WithCred(ctx, cred)`
* call into the same business logic you already have

So the only difference between prod and dev is how the context gets populated.

---

## 5. Build tags connect it all

You already use build tags to exclude control plane code and in-memory adapters from production.

Keep doing that.

* Production build:

  * Includes `spireprod` adapter.
  * Excludes `inmemorydev`.
  * Exposes network listener with mTLS using go-spiffe.

* Development build:

  * Includes `inmemorydev` adapter.
  * Excludes `spireprod`.
  * Exposes Unix socket listener that uses SO_PEERCRED.

Because both adapters satisfy `ports.IdentityService`, the rest of the code does not change.

This gives you:

* Same domain API.
* Same authorization logic.
* Same public surface for other devs.
* Different attestation backend.

---

## 6. Your demo story on Ubuntu 24

When you “demo” on Ubuntu 24 to another developer:

1. You run the server in `dev` build mode.

   * It listens on `/tmp/workload_api.sock`.
   * It attaches SO_PEERCRED creds to the context.
   * It wires `IdentityServiceDev`.

2. You run the client-demo binary.

   * It connects via Unix domain socket.
   * It does not send any headers.

3. The handler calls `identityService.CurrentWorkload(ctx)` and prints the SPIFFE-like ID.

From the outside, it looks like: “look, I get workload identity and authorization with almost zero setup.”
From the inside, it is still real attestation (kernel-backed).

No insecure shortcut. No behavioral drift from production.

---

## Key takeaways

1. The thing you must reuse in dev is not go-spiffe directly. It’s your port (`IdentityService` or similar). That port defines what the rest of the app expects from “identity.”
2. Production adapter: pulls identity from mTLS / SPIRE / go-spiffe.
3. Development adapter: pulls identity from SO_PEERCRED / Linux kernel and fabricates a SPIFFE-like ID string.
4. Both adapters satisfy the same interface. Your business logic, routing, authorization, logging, tracing code stays the same across dev and prod.
5. You enforce this swap cleanly with Go build tags (`//go:build dev` vs `//go:build !dev`).
